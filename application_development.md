# アプリケーション開発のアンチパターン
## 19章: リーダブルパスワード(読み取り可能パスワード)
### 目的: パスワードのリカバリーとリセットを行う
### アンチパターン: パスワードを平文で格納する
- パスワードの格納
    - アプリケーションクライアントからデータベースサーバーに送信されたSQL文のネットワークパケットを傍受することはそこまで難しくない
    - データベースサーバーのSQLクエリログを探す方法もある
    - データベースのバックアップファイルからもデータを読み取れる
- パスワードの認証
- パスワードをメールで送信する
    - 非常に深刻なセキュリティリスク

### アンチパターンを用いても良い場合 
- 自分のアプリケーションがクライアント側になりうる場合

### 解決策: ソルトを付けてパスワードハッシュを格納する
- ハッシュ関数を理解する
- SQLでのハッシュの使用
    - sql標準ではついていないので、各データベースの拡張を使用する
- ハッシュにソルトを加える
    - dictionary attackを防ぐためにハッシュ関数に渡す前にパスワードに連結する無意味な文字列のこと
- SQLからパスワードを隠す
    - SQLではなくアプリケーション側で先にhash化する
- パスワードをリカバリするのではなく、リセットする

## 第20章: SQLインジェクション
### 目的: 動的SQLを記述する
### アンチパターン: 未検証の入力をコードとして実行する
- アクシンデントは起きる
- ウェブ最大のセキュリティ脅威
- 対処法の追求
    - 値のエスケープ
    - プリペアドステートメント
    - ストアドプロシージャ
    - データアクセスフレームワーク
- アンチパターンを用いても良い場合
ない
- 解決策: 誰も信用してはならない
    - 入力のフィルタリング
    - 動的値のパラメータ化
    - 動的値を引用符で囲む
    - ユーザーの入力をコードから隔離する
    - 他の開発者にコードをレビューしてもらう
        1. アプリケーション変数や文字列連結、文字列痴漢によって構築されているSQLステートメントを特定
        1. SQLステートメントで使われている、すべての動的コンテンツの起点を辿り、外部ソースからくる全てのデータを特定
        1. これらの外部コンテンツには全て潜在的なリスクがあると想定し、フィルター/バリデーション/マッピング配列などを用いて、これらの信用性の低いコンテンツを変換
        1. プリペアドステートメントまたは検証済みのエスケープ関数を用いて、SQLステートメントと外部データを組み合わせる
        1. 他にもストアドプロシージャなどの動的SQLステートメントが隠れている可能性がある場所をチェック

## 21章: Pseudokey Neat-Freak(擬似キー潔癖症)
idが欠番になって、うめようとしてしまう
### アンチパターン: 隙間を埋める
- 欠番を割り当てる
    - 最も小さい欠番の値特定のために独自クエリを利用しなければならない
        - 複数の挿入が同時に実行された場合に重複しそう
- 既存業に番号を振り直す
    - 振り直しが大変
    - 振り直しのSQLにすごい時間がかかる
    - 外部キー制約...
    - 削除されていることに何か意味があるかもしれない

### アンチパターンを用いても良い場合
ない

### 解決策: 擬似キーの欠番は埋めない
主キーの値は非NULLであれば良く、連番の必要は全くない
- 行のナンバリング
    - window関数のROW_NUMBER
- GUID(UUID)の使用
128bit の擬似乱数  
  - 同じ機別子が生成される可能性がきわめて低いので、事実上一意な
  - 並列性がたかい
  - 値がランダムなので誰も順番がきにならない
  - インデックス効率がシーケンシャルな ID より劣る
  - GUID の格納には16バイト 一般的な整数は4バイトでディスク効率がわるい
  - 値がランダムなので生成された順番などを推測できない

## 22賞: シー・ノー・エビル(臭いものに蓋)
### 目的: 簡潔なコードを書く
- より短い時間でアプリケーションのコーディングを行う
- テスト、文書化、ピアレビューの対象となるコードの量が減る
- コードが少ないのでバグが混入する可能性も少ない

### アンチパターン: 肝心な部分を見逃す
- 診断せずに判断する
- 見逃しがちなコード

### アンチパターンを用いても良い場合
- エラーに対して全く何もする必要がないときはエラーチェックを省略できる

### 解決策: エラーから優雅に回復する
- リズムを維持する
- ステップをたどり直す

## 23章: ディプロマティック・イミュニティ(外交特権)
### 目的: ベストプラクティスを採用する
ソフトウェアエンジニアリングのベストプラクティス
- ソースコードのバージョン管理
- ユニットテストや機能テストの自動化・実行

### アンチパターン: SQLを特別扱いする
アプリケーションの開発ルールはデータベース開発には当てはまらない
- データベース管理者はいくつかの開発チームを掛け持ちすることがあり「お客さん」のように扱われる
- SQL言語がアプリケーションコード内で特殊な言語として扱われる
- アプリケーションコードを記述するときに使える高度なIDEツールがデータベース開発向けにはない
- データに関する知識や運用権限が一人のデータベース管理者に集中してしまう傾向にある

### アンチパターンを用いても良い場合
- その場限りのコードの場合

### 解決策: 包括的に品質改善に取り組む
#### 文章化
    - ER図
    - テーブル・列・ビュー
    - リレーションシップ
    - トリガ
    - ストアドプロシージャ
    - sqlセキュリティ
    - データベースインフラストラクチャ
    - オブジェクトリレーショナルマッピング

#### バージョン管理
    - データ定義スクリプト
    - トリガとプロシージャ
    - ブートストラップデータ
    - ER図とドキュメント
    - データベース管理スクリプト

#### テスティング
アイソレーションテスト

#### 複数のブランチを扱う
- 各ブランチ向けにそれぞれデータベースインスタンスを構築できると理想的

## 24章: Magic Beans(魔法の豆)
### 目的: MVCのMを単純化する
- モデルを単純化するため、モデルは単なるデータアクセスオブジェクトとしてしまう

### アンチパターン: モデルがアクティブレコードそのもの
#### モデルをデータベーススキーマに強く依存してしまう
- テーブルの数 = Modelの数が必要
- データベーススキーマを変更する場合、Modelの変更だけではなく、そのModelを使うコードも変更する必要が出てくる

#### CRUD機能を公開してしまう
- 意図した用法を無視いsてCRUD操作が行われてしまう

#### ドメインモデル貧血症をもたらす
- CRUD以外の振る舞いがモデルの外部に書かれてしまい、振る舞いの凝縮度が低下する

#### ユニットテストが困難
- モデル
    - データベースアクセスから分離して行うことができない。
- ビュー
    - モデルが関連する動的なHTML要素のレンダリングと解析のために、フレームワークは複雑で時間のかかるコードを実行する必要がある。
- コントローラ：
    - ビジネスロジックがコントローラに書かれていると、ビジネスロジックのテストの為にHTTPリクエストを用意したりと無駄な準備が必要になる。
    - また、同じビジネスロジックが分散しているとテストの重複も発生。

データベースアクセスからビジネスロジックを、プレゼンテーションからビジネスロジックをそれぞれ分離させること！

### アンチパターンを用いても良い場合
- アクティブレコード自体はアンチパターンではない
- 単純なCRUD操作を行うだけのアプリケーションや、スピード重視のプロトタイプ作成時など

### 解決策: Modelがアクティブレコードを「持つ」状態にする
#### モデルを理解する
- アクティブレコードのようなDAOとModelの関係は、継承ではなく集約
- DBのデータを扱うCRUD操作は外部に公開しない
- コントローラやビューはドメインモデルのインターフェースを使用すべき
- 疎結合性
- 高凝縮性

#### ドメインモデルの使用
- Modelはビジネスロジックを実装する場所
- DBとのやりとりは、内部的な実装の詳細。カプセル化
- クラス図書いてみよう。複雑化・密結合化してないか

#### プレーンなオブジェクトのテスト
- 理想は、DBに接続することなくモデルをテストできること
- モデルとコントローラの切り離し
- モデルとデータアクセス機能の分離

#### 現実的に考える
- フレームワークによってはMagic Beansアンチパターンを招きやすいが、DAOは効果的に使用できる

## 25章: 砂の城
### 目的: サービスの安定稼働
### アンチパターン: 想定不足
どんな環境でも、想定を超えるアクセスなどは起こりうる

### アンチパターンを用いても良い場合
- 対策を講じれば講じるほどコストがかさむので、無計画に対策を講じるわけにはいけない
- 規模によっても最適なアーキテクチャが異なる

### 解決策
- ベンチマーク
    - 大きなトラフィックが予想される場合は、事前にどの程度まで許容可能なのかをベンチマークしておく
    - 実際に使用するのと同じシステムでなければベンチマークはあまり参考にならない
        - cpuの性能が1.5倍違うからベンチマークの結果も1.5倍になるというふうにはならない
- テスト環境の構築
- 例外処理
    - ちゃんとどういったエラーが起こりうるのか想像して、例外処理を書いておく必要がある
- バックアップ
    - ディスクの故障やオペミス、クラッカーによる攻撃などによってインシデントは起こりうる
    - RAIDで冗長化しているからバックアップは取らないというのは誤解
        - データが論理的に破壊されてしまう可能性を考慮できていない
- 高可用性
    - どれだけ高級なマシンでも故障しうる
- ディザスタリカバリ
    - 本当に重要なシステムではマシン単位の冗長化では十分でなく、データセンターないしはサイト全体の障害も考慮する必要がある
    - 津波、地震など
- 運用ポリシーの策定
