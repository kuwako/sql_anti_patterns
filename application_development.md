# アプリケーション開発のアンチパターン
## 19章: リーダブルパスワード(読み取り可能パスワード)
### 目的: パスワードのリカバリーとリセットを行う
### アンチパターン: パスワードを平文で格納する
- パスワードの格納
    - アプリケーションクライアントからデータベースサーバーに送信されたSQL文のネットワークパケットを傍受することはそこまで難しくない
    - データベースサーバーのSQLクエリログを探す方法もある
    - データベースのバックアップファイルからもデータを読み取れる
- パスワードの認証
- パスワードをメールで送信する
    - 非常に深刻なセキュリティリスク

### アンチパターンを用いても良い場合 
- 自分のアプリケーションがクライアント側になりうる場合

### 解決策: ソルトを付けてパスワードハッシュを格納する
- ハッシュ関数を理解する
- SQLでのハッシュの使用
    - sql標準ではついていないので、各データベースの拡張を使用する
- ハッシュにソルトを加える
    - dictionary attackを防ぐためにハッシュ関数に渡す前にパスワードに連結する無意味な文字列のこと
- SQLからパスワードを隠す
    - SQLではなくアプリケーション側で先にhash化する
- パスワードをリカバリするのではなく、リセットする

## 第20章: SQLインジェクション
### 目的: 動的SQLを記述する
### アンチパターン: 未検証の入力をコードとして実行する
- アクシンデントは起きる
- ウェブ最大のセキュリティ脅威
- 対処法の追求
    - 値のエスケープ
    - プリペアドステートメント
    - ストアドプロシージャ
    - データアクセスフレームワーク
- アンチパターンを用いても良い場合
ない
- 解決策: 誰も信用してはならない
    - 入力のフィルタリング
    - 動的値のパラメータ化
    - 動的値を引用符で囲む
    - ユーザーの入力をコードから隔離する
    - 他の開発者にコードをレビューしてもらう
        1. アプリケーション変数や文字列連結、文字列痴漢によって構築されているSQLステートメントを特定
        1. SQLステートメントで使われている、すべての動的コンテンツの起点を辿り、外部ソースからくる全てのデータを特定
        1. これらの外部コンテンツには全て潜在的なリスクがあると想定し、フィルター/バリデーション/マッピング配列などを用いて、これらの信用性の低いコンテンツを変換
        1. プリペアドステートメントまたは検証済みのエスケープ関数を用いて、SQLステートメントと外部データを組み合わせる
        1. 他にもストアドプロシージャなどの動的SQLステートメントが隠れている可能性がある場所をチェック

## 21章: Pseudokey Neat-Freak(擬似キー潔癖症)
idが欠番になって、うめようとしてしまう
### アンチパターン: 隙間を埋める
- 欠番を割り当てる
    - 最も小さい欠番の値特定のために独自クエリを利用しなければならない
        - 複数の挿入が同時に実行された場合に重複しそう
- 既存業に番号を振り直す
    - 振り直しが大変
    - 振り直しのSQLにすごい時間がかかる
    - 外部キー制約...
    - 削除されていることに何か意味があるかもしれない

### アンチパターンを用いても良い場合
ない

### 解決策: 擬似キーの欠番は埋めない
主キーの値は非NULLであれば良く、連番の必要は全くない
- 行のナンバリング
    - window関数のROW_NUMBER
- GUID(UUID)の使用
128bit の擬似乱数  
  - 同じ機別子が生成される可能性がきわめて低いので、事実上一意な
  - 並列性がたかい
  - 値がランダムなので誰も順番がきにならない
  - インデックス効率がシーケンシャルな ID より劣る
  - GUID の格納には16バイト 一般的な整数は4バイトでディスク効率がわるい
  - 値がランダムなので生成された順番などを推測できない

