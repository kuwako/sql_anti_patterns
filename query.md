# クエリのアンチパターン
## 13章: フィア・オブ・ジ・アンノウン(恐怖のunknown)
### 目的: 欠けている値を区別する
### アンチパターン: NULLを一般値として使う、または一般値をNULLとして使う
- 式でNULLを扱う
- NULLを許容する列の検索
- プリペアドステートメントでNULLを扱う
- NULLの使用を避ける

### アンチパターンを用いても良い場合
外部データの読み込みや書き出しをする場合

### 解決策: NULLを一意な値として使う
- スカラー式でのNULL
- 論理式でのNULL
- NULLの検索
- 列にNOT NULL制約を宣言する
- 動的なデフォルト

## 14章: アンビギュアスグループ(曖昧なグループ)
### 目的: グループ内で最大値を持つ行を取得する
### アンチパターン: 非グループ化列を参照する
- 単一値の原則(Single-Valued Rule)
- SQLがクエリの意図を汲んでくれるとは限らない

### アンチパターンを用いても良い場合
MySQLやSQLiteを使用していて、関数従属性を持つ列のみにクエリを実行するようプログラマ自身が注意していれば、曖昧さの問題を避けつつ、この種のクエリをグループ化を使用できる

### 解決策: 曖昧でない列を使用する
- 関数従属性のある列のみにクエリを実行する
- 相関サブクエリを使用する
- 導出テーブルを使用する
- JOINを使用する
- 他の列に対しても集約関数を使用する
- グループごとに全ての値を連結する

## 15章: ランダムセレクション
### 目的: サンプル行をフェッチする
- ニュースのハイライトや広告のような、コンテンツのローテンション表示
- 一部のデータの監査
- コールセンターにかかってきた電話のオペレーターへの割り当て
- テストデータの生成

### アンチパターン: データをランダムにソートする
RAND関数やRANDOME関数を使用して、最初の行を取得するのがわかりやすいやり方だが、indexが使用できないデメリットがある  

### アンチパターンを用いても良い場合
- データセットが小さい場合

### 解決策: 特定の順番に依存しない
#### 1と最大値の間のランダムなキーを選択する
主キー値が1から開始され、かつ連続している場合に使用できる  
```sql SELECT b1.* FROM Bugs AS b1 INNER JOIN (SELECT CEIL(RAND() * (SELECT MAX(bug_id) FROM Bugs)) AS rand_id ) AS b2 ON b1.bug_id = b2.rand_id; ```
#### 欠番の穴の後にあるキー値を選択する
#### 全てのキー値のリストを受け取り、ランダムに一つを選択する
- スクリプト側の受け取りが非常に大きくなってしまう可能性がある
- クエリを2回実行する必要がある

#### オフセットを用いてランダムに行を選択する
#### ベンダー依存の解決策
MicrosoftSQLServer2005ではTABLESAMPLE句を使えるので、その関数を使う

## 16章: プアマンズ・サーチエンジン(貧者のサーチエンジン)
### 目的: 全文検索を行う
以下の目的をRDBMSで行いたいとする
- 検索語との一致度の高い記事を上位に表示
- 語形変化対応( crash, crashed, crashed, crashing)
- スケールすること

### アンチパターン: パターンマッチング述語を使う
LIKE句や正規表現による検索  
#### 問題点
- パフォーマンスの低下
  - indexが使えずにフルスキャンが行われる
- 意図しないマッチの発生

### アンチパターンを用いても良い場合
- 検索したいケースが単純である
- パフォーマンスが問題にならない場合

### 解決策: 適切なツールをしようする
- そもそもSQLを使わない
- SQL標準に準拠しつつ、部分文字列マッチングより効率的な転置インデックスを用いる

#### MySQLのフルテキストインデックス
- MyISAM(MySQL3.23以降)
- InnoDB(MySQL5.6以降)
- CHAR, VARCHAR, TEXT型のみ
- 日本語の分かち書き非対応なので、使おうと思うと事前に分かち書きしてスペース区切りにしてからDBに格納する

#### PostgreSQL
専用のデータ型TSVECTORを用い、そのカラムに対して汎用転地インデックス(GIN)を作成する
#### サードパーティのサーチエンジン
- Sphinx Serach
  - MySQLやPostgreSQLとうまく連携できる
  - インデックスの作成と検索が高速
  - 分散クエリもサポート
  - 更新頻度が低いデータに対して、高いスケーラビリティを出すことに向く
- Apache Lucene
  - 独自形式のインデックスを構築。データを更新すると、都度Luceneのインデックスの更新が必要
  
#### 転置インデックス
- ユーザーが新規単語で検索する場合、全文検索が発生
  - あらかじめ全ての単語に対し、キーワードリストを用意しておけば回避可能
- 編集があった場合、交差テーブルの更新が必要
- Keywordsテーブルに、ユーザーがそのキーワードを検索するたびに値が増える列を用意することで、どのキーワードへの需要が高いか分かる。

## 17章: スパゲッティクエリ
### 目的: SQLクエリの数を減らす
短く書いたら優雅だし、ネットワーク間のやりとりが減るというメリットがある  

### アンチパターン: 複雑な問題をワンステップで解決しようとする
#### 意図に反した結果
- 一つのクエリで処理をしようとするとデカルト積が生じることがある

#### さらなる弊害
- デバッグが困難になる
- 実行時のコストがあがりやすい
