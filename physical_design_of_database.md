# データベース物理設計のアンチパターン
## 9章: ラウディングエラー(丸め誤差)
### 目的: 整数の代わりに小数値を使用する
### アンチパターン: FLOATデータ型を使用する
SQLのFLOATデータガタハホカノプログラミングゲンゴノfloat型と同じようにIEEE754標準に従った実数を2進数形式でエンコードする  
FLOAT型を効率的に使うには、その浮動小数点数の特徴を理解しておかなければならない

- 丸めが避けられない
    - 例えば10進数で59.95と表せる数を、2進数では正確に表現できない
- SQLでのFLOATの使用

### アンチパターンを用いても良い場合
FLOATはINTEGERやNUMERICなどのデータ型がサポートするよりも広い範囲の実数を扱う場合に適してるので科学技術計算を行うアプリケーション

### 解決策: NUMERICデータ型を使用する
FLOATヤその類似したデータ型の代わりに、NUMERICやDECIMALを用いて、固定精度の小数点数を表すようにする

## 10章: サーティワンフレーバー
### 目的: 列を特定の値に限定する
### アンチパターン: 限定する値を列定義で指定する
標準SQLでCHECK制約を使用したり、MySQLではENUM型を定義できる  
ENUM型は文字列のアルファベット順ではなく、定義順でソートされるため注意  
DOMAINやユーザー定義型(UDT)を使い、列に入力する値を特定の値のどれかに限定する方法もあるが、未サポートのRDBMSも多い  

- 中身は何だろう
- 新しいフレーバーの追加
    - ENUM値やCHECK制約を追加または削除するための構文はなく、書き換える必要がある  
    ``` ALTER TABLE Bugs MODIFY COLUMN status ENUM('NEW', 'IN PROGRESS', 'FIXED', 'DUPLICATE');  ```
    - 追加する際には、追加前の列定義の有効値が'NEW', 'IN PROGRESS', 'FIXED'だと知っておかなければならない
- 昔ながらの味は色褪せない
    - バグ管理システムの品質管理プロセスを変更し、従来のFIXEDをCODE COMPLETEとVERIFIEDの2つのステージに分けることになった場合、列挙値からFIXEDを削除する場合にすでにstatusがFIXEDになっているレコードはどうするべきなのか
- 移植が困難

### アンチパターンを用いても良い場合
有効値の変更が不要だと断言できる場合

### 解決策: 限定する値をデータで指定する
別テーブルでstatusを管理する
- 値セットの取得
- 参照テーブルの値の更新
- 廃止された値のサポート
- 移植が容易

## 11章: ファントムファイル(幻のファイル)
### 目的: 画像をはじめとする大容量メディアファイルを格納する
画像をどうするか的な

### アンチパターン: 物理ファイルの使用を必須と思い込む
- ファイル削除における問題
- トランザクション分離の問題
- ロールバック時における問題
- データベースのバックアップツール使用時に置ける問題
- SQLアクセス権限使用時における問題
- ファイルはSQLデータ型ではない

### アンチパターンを用いても良い場合
- データベースの容量を減らせる
- データベースのバックアップ時間が短時間で済む
- プレビューや編集が容易になる

### 解決策: 必要に応じてBLOB型を採用する 

## 12章: インデックスショットガン(闇雲インデックス)
### 目的: パフォーマンスを最適化する
インデックスをいつ、どのように使うべきかをきちんと理解しているソフトウェア開発者は多くない  

### アンチパターン: 闇雲にインデックスを使用する
#### インデックスを全く定義しない
- データベース関連の書物や記事にはインデックスの更新によってデータベースにオーバーヘッドが生じると書いている場合が多い
- 必要なオーバーヘッドもあるので安易に考えてはいけない

#### インデックスを多く定義しすぎる
- 主キーへのindexを定義する必要がない(多くのDBの場合)
- varchar(80)などの長い文字列を格納するデータ型へのインデックスは、サイズが大きく、かつそういった列を検索する事例は多くない
- 複合indexは本当に使用する検索かを確認する必要がある(定義する順番も重要)

### アンチパターンを用いても良い場合
- どのような検索がされるかが未定/不明の場合

### 解決策: [MENTOR]の原則に基づいて効果的なインデックス管理を行う
