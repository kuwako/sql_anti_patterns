# データベース論理設計のアンチパターン
## 1章 ジェイウォーク(信号無視)
### 目的: 複数の値を持つ属性を格納する
### アンチパターン: カンマ区切りフォーマットのリストを格納する
- 検索性の低下
    - where句を発行する際に、パターンマッチを用いなければならない
- join性能の低下
- 集約関数の使いづらさ
- 型の判定が不可能
- 区切り文字(,)が要素の中に使われていない保証はない
- リストの長さの制限

### アンチパターンを用いても良い場合
- クエリパフォーマンスの向上のために非正規化のため

### 解決策: 交差テーブルを作る

## 第2章 ナイーブツリー(素朴な木)
### 目的: 階層構造を格納し、クエリを実行する
- 組織図のような上下の構造
- スレッド形式のコメント欄(掲示板)

### アンチパターン: 常に親のみに依存する
- 各レコードが直近のparent_idを持つ
    - 隣接リストと呼ばれる
    - 一連の流れを取得するクエリが複雑になる
    - 集約関数を書くのも大変になる
    - 途中のノードの削除が容易ではない

### アンチパターンを用いても良い場合
- ノードと直近の親と子を取ることに重点を置く場合や列の挿入を容易に行いたい場合

### 解決策: 代替ツリーモデルを使用する
- 経路列挙モデル
    - スレッドの場合、発言idをpathという形で持つ(1/2/4/5/9のように)
    - pathを格納するカラムの大きさに制限を受ける
    - 「パンくず」UIとして効果的だが、参照生合成が保証できず、冗長な情報を格納するため脆弱な面を持っている
- 入れ子集合モデル
    - 直近の親ではなく、子孫の集合に関する情報を各ノードに格納する
    - 非葉ノードを削除してもその一つ上の階層のノードを親と見做すことができる
    - 操作が複雑になる
        - ノードの挿入で新しいノードの左の値より大きい全ての左右のノードを再計算する必要がある
    - 巧妙すぎる設計手法だが、参照生合成を保証できない。ツリーの検査の必要が多い場合に適する
- 閉包テーブルモデル
    - 閉包テーブルはツリー全体のパスを格納する
    - もっとも用途が幅広く、唯一ノードが複数のツリーへ所属することができるが、関連付けを格納するために別のテーブルが必要なのは難点
    - 階層が深くなると多くのレコード数が必要になってしまう

## 3章 IDリクワイアド(とりあえずID)
### 目的: 主キーの規約を確立する
- 行の重複をさけたい
- クエリで個別の行を参照したい
- 外部キー参照をサポートしたい

### アンチパターン: 全てのテーブルにid列を用いる
- 冗長なキーが作成されてしまう
    - 同じテーブルにある別の列が自然なキーに使えそうであったとしても、慣習を重視して、主キーとしてid列を作成してしまう
- 重複行を許可してしまう
- キーの意味がわかりにくくなる
- 複合キーは使いにくい

### アンチパターンを用いても良い場合
- ORMを使う場合
    - convention over configurationの原則

### 解決策
- わかりやすい列名にする
- 規約に縛られない
- 自然キーと複合キーの活用

## 4章 キーレスエントリ(外部キー嫌い)
### 目的: データベースのアーキテクチャを単純化する
#### 以下の理由で外部キーが使用されないことがある
- データの苦心が参照整合制約と衝突してしまう
- データベースが外部キーのために作成するインデックスがパフォーマンスに影響すると考えている

### アンチパターン: 外部キー制約を使用しない
- 完璧なコードを前提にしている
- ミスを調べなければならない
- 外部キー制約によって親も子もupdateできない状況になりうる

### アンチパターンを用いても良い場合
- MyISAMやSQLiteのver3.6.19未満を使用している場合(外部キー制約の機能がないから)

### 解決策: 外部キー制約を宣言する
- 外部キー制約による参照整合性の強制によって、データの不整合をさけることができる
- 複数テーブルの変更をサポートする
    - アプリケーションコードにはマネのできないカスケード更新ができる
        - カスケード更新を使うと親の行の更新や削除が可能になり、その行を参照しているあらゆる子の行もデータベースが適切に処理してくれる
- オーバーヘッドにはならない
    - 外部キー制約によって多少のオーバーヘッドが生じるのは間違いないが、以下のことを別の方法で行うよりは確実に効率が良い
        - 挿入、更新、削除前にチェックのためにselectクエリを実行する必要がなくなる
        - 複数のテーブルの変更を防ぐためにテーブルをロックする必要がない
        - 他の方法のように孤児が生じてしまうことがないので、データ品質管理用スクリプトを定期的に実行する必要がない

## 5章 EVA(エンティティ・アトリビュート・バリュー)
### 目的: 可変属性をサポートする
- 最近のオブジェクト志向プログラミングモデルでは、例えば、同じ基底型を拡張したそれぞれ異なるオブジェクトタイプとの間にも関連を持つ可能性がある
    - バグデータベースの例を使うと、BugとFeatureRequest(機能要望)が基底型であるIssueで共通の属性を共有しているが、Bug, FeatureRequestには別の属性がありうる

### アンチパターン: 汎用的な属性テーブルを使用する
別のテーブルを作成して、属性を「行」に格納すること  
メリットは以下
- 両方のテーブルの列数を減らせる
- 新たな属性をサポートするために列数を増やす必要がない
- 属性が存在しないエンティティの該当列にNULLが入っている、NULLだらけのテーブルになることを防げる

一見設計が改善されたかのように思えるが、処理の複雑さは解消できていない
- 属性を取得するにはどうするのか
- データ整合性をどう保つのか
    - 必須属性を設定できない
    - sqlのデータ型を使えない
    - 参照整合性を強制できない
    - 属性名を補わなければならない
- 行を再構築しなければならない

### アンチパターンを用いても良い場合
特にない。非リレーショナルなデータ管理が必要ならCassandraやHadoop, MongoDB, Redisなどを使うと良い

### 解決策: サブタイプのモデリングを行う
- シングルテーブル継承
    - 全属性を1テーブルに突っ込む方法で以下の欠点がある
        - NULLだらけになる
        - 列の数が増えすぎる
        - どの属性がどのサブタイプに属するかを定義するメタデータがない
    - active recordのような単一テーブルに対するデータベースアクセスパターンを使う必要がある場合は有用
- 具象テーブル継承
    - サブタイプごとにテーブルを作成する。以下の点でシングルテーブル継承と比べてメリットがある
        - サブタイプに存在しない属性列を格納する必要がない点
        - メタデータが不要になる点
    - 全てのオブジェクトをどのサブタイプであるかに関わらず取得したい場合には、各サブタイプが別々のテーブルに格納されているために処理は煩雑になる
        - このクエリを簡単にするために、共通属性のみを選択肢、テーブルをUNIONしたビューを定義するという方法がある
    - 具象テーブル継承設計は全てのサブタイプを跨いだ検索を実行する頻度が低い場合に適切
- クラステーブル継承
    - テーブルをクラスのようにみなして継承を模倣する方法
    - 基底テーブルの行から、行がどのサブタイプを特定する必要はない
        - サブタイプの数が少ない限り、これら全てをジョインするクエリを書くことができる
    - 全てのサブタイプに共通する列を参照するクエリが頻繁に実行されるときに適切
- 半構造化データ
    - サブタイプの数が多い場合は頻繁に新しい属性を追加しなければならない場合はLOB列を追加し、XMLやJSONなどの形式で属性名と値を共に格納することができる
    - 拡張性が高い点がメリット
    - LOB列に対して、SQLからのアクセス性が非常に悪いことがデメリット
    - サブタイプの数を制限できない場合や、新しい属性を随時定義するための高い柔軟性が必要な場合に適切
