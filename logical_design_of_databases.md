# データベース論理設計のアンチパターン
## 1章 ジェイウォーク(信号無視)
### 目的: 複数の値を持つ属性を格納する
### アンチパターン: カンマ区切りフォーマットのリストを格納する
- 検索性の低下
    - where句を発行する際に、パターンマッチを用いなければならない
- join性能の低下
- 集約関数の使いづらさ
- 型の判定が不可能
- 区切り文字(,)が要素の中に使われていない保証はない
- リストの長さの制限

### アンチパターンを用いても良い場合
- クエリパフォーマンスの向上のために非正規化のため

### 解決策: 交差テーブルを作る

## 第2章 ナイーブツリー(素朴な木)
### 目的: 階層構造を格納し、クエリを実行する
- 組織図のような上下の構造
- スレッド形式のコメント欄(掲示板)

### アンチパターン: 常に親のみに依存する
- 各レコードが直近のparent_idを持つ
    - 隣接リストと呼ばれる
    - 一連の流れを取得するクエリが複雑になる
    - 集約関数を書くのも大変になる
    - 途中のノードの削除が容易ではない

### アンチパターンを用いても良い場合
- ノードと直近の親と子を取ることに重点を置く場合や列の挿入を容易に行いたい場合

### 解決策: 代替ツリーモデルを使用する
- 経路列挙モデル
    - スレッドの場合、発言idをpathという形で持つ(1/2/4/5/9のように)
    - pathを格納するカラムの大きさに制限を受ける
    - 「パンくず」UIとして効果的だが、参照生合成が保証できず、冗長な情報を格納するため脆弱な面を持っている
- 入れ子集合モデル
    - 直近の親ではなく、子孫の集合に関する情報を各ノードに格納する
    - 非葉ノードを削除してもその一つ上の階層のノードを親と見做すことができる
    - 操作が複雑になる
        - ノードの挿入で新しいノードの左の値より大きい全ての左右のノードを再計算する必要がある
    - 巧妙すぎる設計手法だが、参照生合成を保証できない。ツリーの検査の必要が多い場合に適する
- 閉包テーブルモデル
    - 閉包テーブルはツリー全体のパスを格納する
    - もっとも用途が幅広く、唯一ノードが複数のツリーへ所属することができるが、関連付けを格納するために別のテーブルが必要なのは難点
    - 階層が深くなると多くのレコード数が必要になってしまう

## 3章 IDリクワイアド(とりあえずID)
### 目的: 主キーの規約を確立する
- 行の重複をさけたい
- クエリで個別の行を参照したい
- 外部キー参照をサポートしたい

### アンチパターン: 全てのテーブルにid列を用いる
- 冗長なキーが作成されてしまう
    - 同じテーブルにある別の列が自然なキーに使えそうであったとしても、慣習を重視して、主キーとしてid列を作成してしまう
- 重複行を許可してしまう
- キーの意味がわかりにくくなる
- 複合キーは使いにくい

### アンチパターンを用いても良い場合
- ORMを使う場合
    - convention over configurationの原則

### 解決策
- わかりやすい列名にする
- 規約に縛られない
- 自然キーと複合キーの活用

## 4章 キーレスエントリ(外部キー嫌い)
### 目的: データベースのアーキテクチャを単純化する
#### 以下の理由で外部キーが使用されないことがある
- データの苦心が参照整合制約と衝突してしまう
- データベースが外部キーのために作成するインデックスがパフォーマンスに影響すると考えている

### アンチパターン: 外部キー制約を使用しない
- 完璧なコードを前提にしている
- ミスを調べなければならない
- 外部キー制約によって親も子もupdateできない状況になりうる

### アンチパターンを用いても良い場合
- MyISAMやSQLiteのver3.6.19未満を使用している場合(外部キー制約の機能がないから)

### 解決策: 外部キー制約を宣言する
- 外部キー制約による参照整合性の強制によって、データの不整合をさけることができる
- 複数テーブルの変更をサポートする
    - アプリケーションコードにはマネのできないカスケード更新ができる
        - カスケード更新を使うと親の行の更新や削除が可能になり、その行を参照しているあらゆる子の行もデータベースが適切に処理してくれる
- オーバーヘッドにはならない
    - 外部キー制約によって多少のオーバーヘッドが生じるのは間違いないが、以下のことを別の方法で行うよりは確実に効率が良い
        - 挿入、更新、削除前にチェックのためにselectクエリを実行する必要がなくなる
        - 複数のテーブルの変更を防ぐためにテーブルをロックする必要がない
        - 他の方法のように孤児が生じてしまうことがないので、データ品質管理用スクリプトを定期的に実行する必要がない

## 5章 EVA(エンティティ・アトリビュート・バリュー)
### 目的: 可変属性をサポートする
- 最近のオブジェクト志向プログラミングモデルでは、例えば、同じ基底型を拡張したそれぞれ異なるオブジェクトタイプとの間にも関連を持つ可能性がある
    - バグデータベースの例を使うと、BugとFeatureRequest(機能要望)が基底型であるIssueで共通の属性を共有しているが、Bug, FeatureRequestには別の属性がありうる

### アンチパターン: 汎用的な属性テーブルを使用する
別のテーブルを作成して、属性を「行」に格納すること  
メリットは以下
- 両方のテーブルの列数を減らせる
- 新たな属性をサポートするために列数を増やす必要がない
- 属性が存在しないエンティティの該当列にNULLが入っている、NULLだらけのテーブルになることを防げる

一見設計が改善されたかのように思えるが、処理の複雑さは解消できていない
- 属性を取得するにはどうするのか
- データ整合性をどう保つのか
    - 必須属性を設定できない
    - sqlのデータ型を使えない
    - 参照整合性を強制できない
    - 属性名を補わなければならない
- 行を再構築しなければならない

### アンチパターンを用いても良い場合
特にない。非リレーショナルなデータ管理が必要ならCassandraやHadoop, MongoDB, Redisなどを使うと良い

### 解決策: サブタイプのモデリングを行う
- シングルテーブル継承
    - 全属性を1テーブルに突っ込む方法で以下の欠点がある
        - NULLだらけになる
        - 列の数が増えすぎる
        - どの属性がどのサブタイプに属するかを定義するメタデータがない
    - active recordのような単一テーブルに対するデータベースアクセスパターンを使う必要がある場合は有用
- 具象テーブル継承
    - サブタイプごとにテーブルを作成する。以下の点でシングルテーブル継承と比べてメリットがある
        - サブタイプに存在しない属性列を格納する必要がない点
        - メタデータが不要になる点
    - 全てのオブジェクトをどのサブタイプであるかに関わらず取得したい場合には、各サブタイプが別々のテーブルに格納されているために処理は煩雑になる
        - このクエリを簡単にするために、共通属性のみを選択肢、テーブルをUNIONしたビューを定義するという方法がある
    - 具象テーブル継承設計は全てのサブタイプを跨いだ検索を実行する頻度が低い場合に適切
- クラステーブル継承
    - テーブルをクラスのようにみなして継承を模倣する方法
    - 基底テーブルの行から、行がどのサブタイプを特定する必要はない
        - サブタイプの数が少ない限り、これら全てをジョインするクエリを書くことができる
    - 全てのサブタイプに共通する列を参照するクエリが頻繁に実行されるときに適切
- 半構造化データ
    - サブタイプの数が多い場合は頻繁に新しい属性を追加しなければならない場合はLOB列を追加し、XMLやJSONなどの形式で属性名と値を共に格納することができる
    - 拡張性が高い点がメリット
    - LOB列に対して、SQLからのアクセス性が非常に悪いことがデメリット
    - サブタイプの数を制限できない場合や、新しい属性を随時定義するための高い柔軟性が必要な場合に適切

## 6章: ポリモーフィック関連
複数の親テーブルに紐づきうるデータをどう格納するのか問題

### 目的: 複数の親テーブルを参照する

### アンチパターン: 二重目的の外部キーを使用する
- ポリモーフィック関連を定義する
    - Commentsテーブルにissue_idに加えてissue_type列を宣言し、BugsかFeatureRequestsが格納される
    - issue_idのための外部キー宣言ができない=参照整合性制約を定義できない
    - Comments.issue_type内の文字列データがデータベースに存在するテーブル名に対応していることを保証するメタデータもない
- ポリモーフィック関連へのクエリ実行
- 非オブジェクト指向の例

### アンチパターンを用いても良い場合
ポリモーフィック関連の使用は避け、外部キー制約などを用いて、参照整合性を保証するようにするべき  
HibernateなどのORMフレームワークを用いる場合、このアンチパターンを使わざるを得ない状況がありうる  

### 解決策: 関連(リレーションシップ)を単純化する
- 参照を逆にする
    - TODO 問題の本質が何かを考えるとすぐにわかる。すなわちポリモーフィック関連では「本来あるべき関連が、逆さまになっている」のです(?)
- 交差テーブルの作成
    - 子テーブル側であるCommentsの外部キーでは、複数の親テーブルを参照できない
        - 複数の外部キーを、Commentsテーブルを参照するために使用する
        - 複数の親テーブルに対応した交差テーブルを作成し、各交差テーブルではCOmmentsへの外部きーに加えて、各親テーブルへおm同じく外部キーを定義する
- 交差点に交通信号を設置する
- 両方の「道」を見る
- 「道」を合流させる
    - UNION使って1テーブルにみせかける
    - 複雑になるので、ビューを検討するといいかもしれない
- 共通の親テーブルの作成
    - CommentsをIssueに紐づけてしまう方法

## 7章: マルチカラムアトリビュート(複数列属性)
### 目的: 複数の値を持つ属性を格納する
1つのテーブルにぞくするべきだと思える属性にふくすうの値がある場合、それをどう格納するのか

### アンチパターン: 複数の列を定義する
対象の属性には複数値を許可しないといけないが、ジェイウォーク(信号無視)アンチパターンで見たように、複数値をカンマ区切りで1列に格納すべきではない  
よって、例えばBugsテーブルにtag1, tag2, tag3というカラムをつけるのが良いと思えるかもしれない
- 値の検索
    - タグ検索のときに全カラムに検索をかける必要が出て来てしまう
- 値の追加と削除
    - 複数の列に対する値の追加や削除にも問題が生じる
- 一意性の保証
- 増加する値の処理
    - 列数が3では足りなくなるかもしれない
        - すでに格納されているテーブル構造を変更するには同時に接続している他のクライアントからのアクセスを防ぐためにテーブル全体をロックする必要があるかもしれない
        - データベースによっては新規テーブルを定義する必要がある
        - マルチカラムアトリビュートの列たちにさらに列を加えると、このテーブルを使う全てのアプリケーションの全てのSQL文を編集する必要がある
### アンチパターンを用いてもいい場合
- 属性値の選択肢を限定できる場合
    - 複数のユーザーアカウントと関連づけられるものの、各関連の役割が異なるようなBugsエンティティを設計した場合

### 解決策: 従属テーブルを作成する
- 属性を格納する列を1つ持つ従属テーブルを作成し、属性を格納する

## 8章: メタデータトリブル(メタデータ大増殖)
### 目的: スケーラビリティを高める
### アンチパターン: テーブルや列をコピーする
- 以下2点の問題が生じる
    - 行数の多いテーブルを、複数のテーブルに分割する(あるテーブルの属性の区別しやすいデータ値に基づいてテーブルを命名する)
    - 列を複数列に分割する(別の属性の区別しやすい値に基づいて列を命名する)
- テーブルの増殖
- データの整合性を管理する
- データの同期をする
- 一意性の保証
- テーブルを跨いだクエリ実行
- メタデータの同期
- 参照整合性の管理
- メタデータトリブル列の特定

### アンチパターンを用いても良い場合
過去データを最新のデータから分離するようなアーカイブが目的の場合

### 解決策: パーティショニングと正規化を行う
- 水平パーティショニング(シャーディング)の使用
- 垂直パーティショニングの使用
- 従属テーブルの導入
