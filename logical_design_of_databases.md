# データベース論理設計のアンチパターン
## 1章 ジェイウォーク(信号無視)
### 目的: 複数の値を持つ属性を格納する
### アンチパターン: カンマ区切りフォーマットのリストを格納する
- 検索性の低下
    - where句を発行する際に、パターンマッチを用いなければならない
- join性能の低下
- 集約関数の使いづらさ
- 型の判定が不可能
- 区切り文字(,)が要素の中に使われていない保証はない
- リストの長さの制限

### アンチパターンを用いても良い場合
- クエリパフォーマンスの向上のために非正規化のため

### 解決策: 交差テーブルを作る

## 第2章 ナイーブツリー(素朴な木)
### 目的: 階層構造を格納し、クエリを実行する
- 組織図のような上下の構造
- スレッド形式のコメント欄(掲示板)

### アンチパターン: 常に親のみに依存する
- 各レコードが直近のparent_idを持つ
    - 隣接リストと呼ばれる
    - 一連の流れを取得するクエリが複雑になる
    - 集約関数を書くのも大変になる
    - 途中のノードの削除が容易ではない

### アンチパターンを用いても良い場合
- ノードと直近の親と子を取ることに重点を置く場合や列の挿入を容易に行いたい場合

### 解決策: 代替ツリーモデルを使用する
- 経路列挙モデル
    - スレッドの場合、発言idをpathという形で持つ(1/2/4/5/9のように)
    - pathを格納するカラムの大きさに制限を受ける
    - 「パンくず」UIとして効果的だが、参照生合成が保証できず、冗長な情報を格納するため脆弱な面を持っている
- 入れ子集合モデル
    - 直近の親ではなく、子孫の集合に関する情報を各ノードに格納する
    - 非葉ノードを削除してもその一つ上の階層のノードを親と見做すことができる
    - 操作が複雑になる
        - ノードの挿入で新しいノードの左の値より大きい全ての左右のノードを再計算する必要がある
    - 巧妙すぎる設計手法だが、参照生合成を保証できない。ツリーの検査の必要が多い場合に適する
- 閉包テーブルモデル
    - 閉包テーブルはツリー全体のパスを格納する
    - もっとも用途が幅広く、唯一ノードが複数のツリーへ所属することができるが、関連付けを格納するために別のテーブルが必要なのは難点
    - 階層が深くなると多くのレコード数が必要になってしまう

## 3章 IDリクワイアド(とりあえずID)
### 目的: 主キーの規約を確立する
- 行の重複をさけたい
- クエリで個別の行を参照したい
- 外部キー参照をサポートしたい

### アンチパターン: 全てのテーブルにid列を用いる
- 冗長なキーが作成されてしまう
    - 同じテーブルにある別の列が自然なキーに使えそうであったとしても、慣習を重視して、主キーとしてid列を作成してしまう
- 重複行を許可してしまう
- キーの意味がわかりにくくなる
- 複合キーは使いにくい





